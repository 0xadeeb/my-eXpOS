//library
loadi(63, 13);
loadi(64, 14);

//timer Interrupt
loadi(4, 17);
loadi(5, 18);

//disk interrupt handler
loadi(6, 19);
loadi(7, 20);

//console interrupt handler
loadi(8, 21);
loadi(9, 22);

//idle program
loadi(69, 11);
loadi(70, 12);

//Init program
loadi(65, 7);
loadi(66, 8);

//exception handler routine
loadi(2, 15);
loadi(3, 16);

//int 4
loadi(10, 23);
loadi(11, 24);

//int 5
loadi(12, 25);
loadi(13, 26);

//int 6
loadi(14, 27);
loadi(15, 28);

//int 7
loadi(16, 29);
loadi(17, 30);

//int 8
loadi(18, 31);
loadi(19, 32);

//int 9
loadi(20, 33);
loadi(21, 34);

//int 10
loadi(22, 35);
loadi(23, 36);

//int 11
loadi(24, 37);
loadi(25, 38);

//int 13
loadi(28, 41);
loadi(29, 42);

//int 14
loadi(30, 43);
loadi(31, 44);

//int 15
loadi(32, 45);
loadi(33, 46);

//resource managment module (module 0)
loadi(40, 53);
loadi(41, 54);

//process manager module (module 1)
loadi(42, 55);
loadi(43, 56);

//memory manager module (module 2)
loadi(44, 57);
loadi(45, 58);

//file manager module (module 3)
loadi(46, 59);
loadi(47, 60);

//device manager module (module 4)
loadi(48, 61);
loadi(49, 62);

//context switch module (module 5)
loadi(50 ,63);
loadi(51 ,64);

//inode table
loadi(59, 3);

//disk free list
loadi(61, 2);

//root file
loadi(62, 5);

[TERMINAL_STATUS_TABLE] = 0;
[DISK_STATUS_TABLE] = 0;

// Current user
[SYSTEM_STATUS_TABLE] = ROOT;
// Process table of init program
[PROCESS_TABLE + 16] = 0;
[PROCESS_TABLE + 17] = 1;
[PROCESS_TABLE + 19] = ROOT;
[PROCESS_TABLE + 20] = CREATED;
[PROCESS_TABLE + 27] = 80;
[PROCESS_TABLE + 28] = 0;
[PROCESS_TABLE + 29] = 8 * PAGE_SIZE;
[PROCESS_TABLE + 30] = PAGE_TABLE_BASE + 20;
[PROCESS_TABLE + 31] = 10;

// Per process resource table of init
alias pprm R0;
pprm = 80 * PAGE_SIZE + RESOURCE_TABLE_OFFSET;
alias idx R1;
idx = 0;
while (idx < 16) do
    [pprm + idx] = -1;
    idx = idx + 2;
endwhile;

//Init Program
//Library
[PAGE_TABLE_BASE + 20] = 63;
[PAGE_TABLE_BASE + 21] = "0100";
[PAGE_TABLE_BASE + 22] = 64;
[PAGE_TABLE_BASE + 23] = "0100";

//Heap
[PAGE_TABLE_BASE + 24] = 78;
[PAGE_TABLE_BASE + 25] = "0110";
[PAGE_TABLE_BASE + 26] = 79;
[PAGE_TABLE_BASE + 27] = "0110";

//Code
[PAGE_TABLE_BASE + 28] = 65;
[PAGE_TABLE_BASE + 29] = "0100";
[PAGE_TABLE_BASE + 30] = 66;
[PAGE_TABLE_BASE + 31] = "0100";
[PAGE_TABLE_BASE + 32] = -1;
[PAGE_TABLE_BASE + 33] = "0000";
[PAGE_TABLE_BASE + 34] = -1;
[PAGE_TABLE_BASE + 35] = "0000";

//Stack
[PAGE_TABLE_BASE + 36] = 76;
[PAGE_TABLE_BASE + 37] = "0110";
[PAGE_TABLE_BASE + 38] = 77;
[PAGE_TABLE_BASE + 39] = "0110";

//Disk map list of init
[DISK_MAP_TABLE + 10] = -1;
[DISK_MAP_TABLE + 11] = -1;
[DISK_MAP_TABLE + 12] = -1;
[DISK_MAP_TABLE + 13] = -1;
[DISK_MAP_TABLE + 14] = 7;
[DISK_MAP_TABLE + 15] = 8;
[DISK_MAP_TABLE + 16] = -1;
[DISK_MAP_TABLE + 17] = -1;
[DISK_MAP_TABLE + 18] = -1;
[DISK_MAP_TABLE + 19] = -1;

// Set IP in top of the stack
[76 * 512] = [65 * 512 + 1];

alias i R0;
i = 2;
while (i < MAX_PROC_NUM) do
    [PROCESS_TABLE + i * 16] = -1;
    [PROCESS_TABLE + i * 16 + 4] = TERMINATED;
    i = i + 1;
endwhile;

// initialize MEMORY_FREE_LIST
i = 0;
// For init and idle programs
while (i < 83) do
    [MEMORY_FREE_LIST + i] = 1;
    i = i + 1;
endwhile;
// For all the others

// MAX_MEM_PAGE set to be 512 not 128 spl error
//while (i < MAX_MEM_PAGE) do
while (i < 128) do
    [MEMORY_FREE_LIST + i] = 0;
    i = i + 1;
endwhile;
[SYSTEM_STATUS_TABLE + 3] = 0;
// [SYSTEM_STATUS_TABLE + 2] = MAX_MEM_PAGE - 83;
[SYSTEM_STATUS_TABLE + 2] = 128 - 83;

// Initialize semaphore table
i = 0;
while (i < MAX_SEM_COUNT) do
    [SEMAPHORE_TABLE + 4 * i] = -1;
    [SEMAPHORE_TABLE + 4 * i + 1] = 0;
    i = i + 1;
endwhile;

// Initialize file status table
i = 0;
while (i < MAX_FILE_NUM) do
    [FILE_STATUS_TABLE + 4 * i] = -1;
    [FILE_STATUS_TABLE + 4 * i + 1] = -1;
    i = i + 1;
endwhile;

// Initialize buffer table
i = 0;
while (i < MAX_BUFFER) do
    [BUFFER_TABLE + 4 * i] = -1;
    [BUFFER_TABLE + 4 * i + 1] = 0;
    [BUFFER_TABLE + 4 * i + 2] = -1;
    i = i + 1;
endwhile;

// Initialize open file table
i = 0;
while (i < MAX_OPENFILE_NUM) do
    [OPEN_FILE_TABLE + 4 * i] = -1;
    [OPEN_FILE_TABLE + 4 * i + 1] = 0;
    i = i + 1;
endwhile;

return;