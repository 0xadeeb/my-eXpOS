// Mod 4
alias functionNum R1;
alias currentPID R2;

if (functionNum == TERMINAL_WRITE) then
    multipush(R1, R2, R3);
    R1 = ACQUIRE_TERMINAL;
    R2 = currentPID;
    call RESOURCE_MANAGER;
    multipop(R1, R2, R3);
    print R3;
    multipush(R1, R2, R3);
    R1 = RELEASE_TERMINAL;
    R2 = currentPID;
    call RESOURCE_MANAGER;
    multipop(R1, R2, R3);
    return;
endif;

if (functionNum == TERMINAL_READ) then
    multipush(R1, R2, R3);
    R1 = ACQUIRE_TERMINAL;
    R2 = currentPID;
    call RESOURCE_MANAGER;
    multipop(R1, R2, R3);
    read;
    [PROCESS_TABLE + 16 * currentPID + 4] = WAIT_TERMINAL;
    multipush(R1, R2, R3);
    call CONTEXT_SWITCH;
    multipop(R1, R2, R3);
    alias writeAddr R4;
    writeAddr = [PTBR + 2 * R3 / PAGE_SIZE] * PAGE_SIZE + R3 % PAGE_SIZE;
    [writeAddr] = [PROCESS_TABLE + 16 * currentPID + 8];
    return;
endif;

if (functionNum == DISK_LOAD) then
    alias pageNo R3;
    alias blockNo R4;

    multipush(R1, R2, R3, R4);
    R1 = ACQUIRE_DISK;
    R2 = currentPID;
    call RESOURCE_MANAGER;
    multipop(R1, R2, R3, R4);

    [DISK_STATUS_TABLE + 1] = 0;
    [DISK_STATUS_TABLE + 2] = pageNo;
    [DISK_STATUS_TABLE + 3] = blockNo;
    load(pageNo, blockNo);
    [PROCESS_TABLE + currentPID * PT_ENTRY_SIZE + 4] = WAIT_DISK;

    // No need to store context (I hope!)
    call SCHEDULER;
    
    return;
endif;